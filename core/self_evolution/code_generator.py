"""
Digital Being â€” Code Generator
Stage 30: Generate new code for self-improvement.
"""

from __future__ import annotations

import ast
import json
import logging
import time
from pathlib import Path
from typing import Any

log = logging.getLogger("digital_being.code_generator")

class CodeGenerator:
    """
    Generates new code for system improvement.
    
    Features:
    - Template-based generation
    - Syntax validation
    - Documentation auto-generation
    - Safety checks
    - Pattern-based creation
    """
    
    SAFE_MODULES = {
        "pathlib", "json", "time", "logging", "typing",
        "dataclasses", "enum", "collections", "itertools"
    }
    
    DANGEROUS_PATTERNS = [
        "exec", "eval", "__import__", "compile",
        "os.system", "subprocess", "open(", "rm -rf"
    ]
    
    def __init__(self, state_path: Path, templates_path: Path) -> None:
        self._state_path = state_path / "code_generator.json"
        self._templates_path = templates_path
        
        self._state = {
            "generated_modules": [],
            "generation_count": 0,
            "failed_generations": 0,
            "templates_used": {},
        }
        
        self._load_state()
        self._ensure_templates()
    
    def _load_state(self) -> None:
        """Load generator state"""
        if self._state_path.exists():
            try:
                with self._state_path.open("r", encoding="utf-8") as f:
                    self._state = json.load(f)
                log.info("CodeGenerator: loaded state")
            except Exception as e:
                log.error(f"CodeGenerator: failed to load state: {e}")
    
    def _save_state(self) -> None:
        """Save generator state"""
        try:
            self._state_path.parent.mkdir(parents=True, exist_ok=True)
            with self._state_path.open("w", encoding="utf-8") as f:
                json.dump(self._state, f, indent=2, ensure_ascii=False)
        except Exception as e:
            log.error(f"CodeGenerator: failed to save state: {e}")
    
    def _ensure_templates(self) -> None:
        """Ensure template directory exists with basic templates"""
        self._templates_path.mkdir(parents=True, exist_ok=True)
        
        # Create basic template if not exists
        basic_template = self._templates_path / "basic_module.py.template"
        if not basic_template.exists():
            template_content = '''"""\n{module_name} - {description}\nAuto-generated by Digital Being\n"""\n\nimport logging\nfrom typing import Any\n\nlog = logging.getLogger("digital_being.{module_name}")\n\nclass {class_name}:\n    """\n    {description}\n    """\n    \n    def __init__(self):\n        self._state = {{}}\n        log.info("{class_name} initialized")\n    \n    def process(self, data: Any) -> Any:\n        """Process data."""\n        log.debug(f"Processing: {{data}}")\n        # TODO: Implement processing logic\n        return data\n    \n    def get_stats(self) -> dict:\n        """Get statistics."""\n        return {{\n            "state": self._state\n        }}\n'''
            basic_template.write_text(template_content, encoding="utf-8")
            log.info("CodeGenerator: created basic template")
    
    def validate_syntax(self, code: str) -> tuple[bool, str]:
        """
        Validate Python syntax.
        
        Args:
            code: Python code to validate
        
        Returns:
            (is_valid, error_message)
        """
        try:
            ast.parse(code)
            return True, ""
        except SyntaxError as e:
            return False, f"Syntax error at line {e.lineno}: {e.msg}"
        except Exception as e:
            return False, f"Parse error: {str(e)}"
    
    def check_safety(self, code: str) -> tuple[bool, list[str]]:
        """
        Check code for dangerous patterns.
        
        Args:
            code: Python code to check
        
        Returns:
            (is_safe, list of issues)
        """
        issues = []
        
        for pattern in self.DANGEROUS_PATTERNS:
            if pattern in code:
                issues.append(f"Dangerous pattern detected: {pattern}")
        
        # Check imports
        try:
            tree = ast.parse(code)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        if alias.name not in self.SAFE_MODULES:
                            issues.append(f"Unsafe import: {alias.name}")
                elif isinstance(node, ast.ImportFrom):
                    if node.module and node.module not in self.SAFE_MODULES:
                        issues.append(f"Unsafe import from: {node.module}")
        except Exception as e:
            issues.append(f"Could not analyze imports: {str(e)}")
        
        return len(issues) == 0, issues
    
    def generate_from_template(
        self,
        template_name: str,
        parameters: dict[str, Any]
    ) -> str:
        """
        Generate code from template.
        
        Args:
            template_name: Template file name
            parameters: Template parameters
        
        Returns:
            Generated code
        """
        template_path = self._templates_path / f"{template_name}.template"
        
        if not template_path.exists():
            raise FileNotFoundError(f"Template not found: {template_name}")
        
        template = template_path.read_text(encoding="utf-8")
        
        # Simple string formatting
        try:
            code = template.format(**parameters)
        except KeyError as e:
            raise ValueError(f"Missing template parameter: {e}")
        
        return code
    
    def generate_module(
        self,
        module_name: str,
        description: str,
        template: str = "basic_module.py",
        additional_methods: list[dict] | None = None
    ) -> dict:
        """
        Generate a new module.
        
        Args:
            module_name: Module name (snake_case)
            description: Module description
            template: Template to use
            additional_methods: Additional methods to add
        
        Returns:
            Generation result dict
        """
        start_time = time.time()
        
        # Generate class name (PascalCase)
        class_name = "".join(word.capitalize() for word in module_name.split("_"))
        
        # Prepare parameters
        parameters = {
            "module_name": module_name,
            "class_name": class_name,
            "description": description,
        }
        
        try:
            # Generate base code
            code = self.generate_from_template(template, parameters)
            
            # Add additional methods if provided
            if additional_methods:
                for method in additional_methods:
                    method_code = self._generate_method(
                        method.get("name", "new_method"),
                        method.get("description", ""),
                        method.get("parameters", []),
                        method.get("return_type", "Any")
                    )
                    # Insert before get_stats method
                    code = code.replace(
                        "    def get_stats",
                        f"{method_code}\n\n    def get_stats"
                    )
            
            # Validate syntax
            is_valid, error = self.validate_syntax(code)
            if not is_valid:
                self._state["failed_generations"] += 1
                self._save_state()
                return {
                    "success": False,
                    "error": f"Syntax validation failed: {error}",
                    "code": None
                }
            
            # Check safety
            is_safe, issues = self.check_safety(code)
            if not is_safe:
                self._state["failed_generations"] += 1
                self._save_state()
                return {
                    "success": False,
                    "error": f"Safety check failed: {', '.join(issues)}",
                    "code": None
                }
            
            # Success
            generation_time = time.time() - start_time
            
            result = {
                "module_name": module_name,
                "class_name": class_name,
                "code": code,
                "description": description,
                "generated_at": time.time(),
                "generation_time": generation_time,
                "template_used": template,
                "lines_of_code": len(code.split("\n"))
            }
            
            # Update state
            self._state["generated_modules"].append({
                "module_name": module_name,
                "timestamp": time.time(),
                "template": template
            })
            self._state["generation_count"] += 1
            
            # Track template usage
            if template not in self._state["templates_used"]:
                self._state["templates_used"][template] = 0
            self._state["templates_used"][template] += 1
            
            self._save_state()
            
            log.info(
                f"CodeGenerator: generated module '{module_name}' "
                f"({result['lines_of_code']} lines) in {generation_time:.2f}s"
            )
            
            return {
                "success": True,
                "result": result,
                "error": None
            }
        
        except Exception as e:
            self._state["failed_generations"] += 1
            self._save_state()
            
            log.error(f"CodeGenerator: generation failed: {e}")
            
            return {
                "success": False,
                "error": str(e),
                "code": None
            }
    
    def _generate_method(
        self,
        method_name: str,
        description: str,
        parameters: list[tuple[str, str]],
        return_type: str
    ) -> str:
        """
        Generate a method definition.
        
        Args:
            method_name: Method name
            description: Method description
            parameters: List of (name, type) tuples
            return_type: Return type annotation
        
        Returns:
            Method code
        """
        # Build parameter list
        params = ["self"]
        for param_name, param_type in parameters:
            params.append(f"{param_name}: {param_type}")
        
        params_str = ", ".join(params)
        
        # Generate docstring
        method_code = f'''    def {method_name}({params_str}) -> {return_type}:
        """
        {description}
        """\n'''
        
        # Add parameter documentation
        if parameters:
            method_code += "        Args:\n"
            for param_name, _ in parameters:
                method_code += f"            {param_name}: Parameter description\n"
        
        # Add return documentation
        if return_type != "None":
            method_code += f"        \n        Returns:\n            {return_type}\n"
        
        # Add implementation placeholder
        method_code += "        # TODO: Implement method logic\n"
        
        if return_type != "None":
            if return_type == "dict":
                method_code += "        return {}\n"
            elif return_type == "list":
                method_code += "        return []\n"
            elif return_type == "bool":
                method_code += "        return True\n"
            else:
                method_code += "        return None\n"
        else:
            method_code += "        pass\n"
        
        return method_code
    
    def get_generated_modules(self) -> list[dict]:
        """Get list of generated modules."""
        return self._state["generated_modules"]
    
    def get_stats(self) -> dict:
        """Get generation statistics."""
        success_rate = 0.0
        total = self._state["generation_count"] + self._state["failed_generations"]
        if total > 0:
            success_rate = self._state["generation_count"] / total
        
        return {
            "total_generated": self._state["generation_count"],
            "failed_generations": self._state["failed_generations"],
            "success_rate": success_rate,
            "templates_used": self._state["templates_used"],
            "modules": len(self._state["generated_modules"])
        }
